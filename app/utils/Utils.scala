package utils

import scala.concurrent.Future

/**
 * Created by paul on 3/22/14.
 */
object Utils {

  /*
    The arguments to predicate should be call-by-name, so they can remain unevaluated if condition is true
    However, the compiler converts call-by-name parameters of type T with Function0[T],
    and type erasure rears its ugly head once again
   */

  // Predicate is used in place of in if statement in for comprehensions over futures.
  // It allows for custom errors instead of the NoSuchElement exception generated by if statements
  // use: _ <- predicate(foo.isBar(), "foo is not bar")
  def predicate(condition: Boolean, fail: String): Future[Unit] =
    if (condition) Future.successful( () ) else Future.failed(Predicate(fail))

  // Predicate is used in place of in if statement in for comprehensions over futures.
  // It allows for custom errors instead of the NoSuchElement exception generated by if statements
  // use: _ <- predicate(foo.isBar(), MyThrowable("foo is not bar"))
  def predicate(condition: Boolean, fail: Throwable): Future[Unit] =
    if (condition) Future.successful( () ) else Future.failed(fail)

  def match_or_else[A, B](to_match: A, fail: => String)(pf: PartialFunction[A, B]): Future[B] =
    if (pf.isDefinedAt(to_match)){
      try{
        Future.successful( pf(to_match) )
      } catch {
        case e: Throwable => Future.failed(e)
      }
    }else{
      Future.failed(Predicate(fail))
    }

  case class UserVisibleError(reason: String) extends Exception(s"user visible error:: $reason")
  
  case class Predicate(reason: String) extends Exception(s"predicate failed:: $reason")
}
